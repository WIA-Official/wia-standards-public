//! GitLab CI Integration
//!
//! Generate GitLab CI pipelines for security scanning.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use super::{CicdResult, CicdError, SecurityScanConfig};

/// GitLab CI configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitLabCiConfig {
    /// Pipeline stages
    pub stages: Vec<String>,
    /// Variables
    pub variables: HashMap<String, String>,
    /// Security scan configuration
    pub scan_config: SecurityScanConfig,
    /// Enable SAST
    pub enable_sast: bool,
    /// Enable DAST
    pub enable_dast: bool,
    /// Enable dependency scanning
    pub enable_dependency_scanning: bool,
    /// Enable container scanning
    pub enable_container_scanning: bool,
    /// Enable secret detection
    pub enable_secret_detection: bool,
    /// Enable license scanning
    pub enable_license_scanning: bool,
    /// Custom rules
    pub custom_rules: Vec<GitLabRule>,
}

/// GitLab CI rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitLabRule {
    /// Rule condition
    #[serde(rename = "if")]
    pub condition: String,
    /// When to run
    pub when: String,
    /// Allow failure
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_failure: Option<bool>,
}

impl Default for GitLabCiConfig {
    fn default() -> Self {
        Self {
            stages: vec![
                "build".to_string(),
                "test".to_string(),
                "security".to_string(),
                "deploy".to_string(),
            ],
            variables: HashMap::new(),
            scan_config: SecurityScanConfig::default(),
            enable_sast: true,
            enable_dast: false,
            enable_dependency_scanning: true,
            enable_container_scanning: true,
            enable_secret_detection: true,
            enable_license_scanning: true,
            custom_rules: vec![],
        }
    }
}

/// GitLab CI pipeline generator
pub struct GitLabCiGenerator {
    config: GitLabCiConfig,
}

impl GitLabCiGenerator {
    /// Create new generator
    pub fn new(config: GitLabCiConfig) -> Self {
        Self { config }
    }

    /// Generate full .gitlab-ci.yml
    pub fn generate_pipeline(&self) -> CicdResult<String> {
        let mut yaml = String::new();

        // Header comment
        yaml.push_str("# WIA Security GitLab CI Pipeline\n");
        yaml.push_str("# Generated by WIA Security Integration\n\n");

        // Include security templates
        yaml.push_str("include:\n");
        if self.config.enable_sast {
            yaml.push_str("  - template: Security/SAST.gitlab-ci.yml\n");
        }
        if self.config.enable_dast {
            yaml.push_str("  - template: Security/DAST.gitlab-ci.yml\n");
        }
        if self.config.enable_dependency_scanning {
            yaml.push_str("  - template: Security/Dependency-Scanning.gitlab-ci.yml\n");
        }
        if self.config.enable_container_scanning {
            yaml.push_str("  - template: Security/Container-Scanning.gitlab-ci.yml\n");
        }
        if self.config.enable_secret_detection {
            yaml.push_str("  - template: Security/Secret-Detection.gitlab-ci.yml\n");
        }
        if self.config.enable_license_scanning {
            yaml.push_str("  - template: Security/License-Scanning.gitlab-ci.yml\n");
        }
        yaml.push('\n');

        // Stages
        yaml.push_str("stages:\n");
        for stage in &self.config.stages {
            yaml.push_str(&format!("  - {}\n", stage));
        }
        yaml.push('\n');

        // Variables
        yaml.push_str("variables:\n");
        yaml.push_str("  WIA_SECURITY_VERSION: \"1.0.0\"\n");
        yaml.push_str(&format!("  WIA_FAIL_ON_CRITICAL: \"{}\"\n", self.config.scan_config.fail_on_critical));
        yaml.push_str(&format!("  WIA_FAIL_ON_HIGH: \"{}\"\n", self.config.scan_config.fail_on_high));
        yaml.push_str(&format!("  WIA_MAX_CRITICAL: \"{}\"\n", self.config.scan_config.max_critical));
        yaml.push_str(&format!("  WIA_MAX_HIGH: \"{}\"\n", self.config.scan_config.max_high));
        for (key, value) in &self.config.variables {
            yaml.push_str(&format!("  {}: \"{}\"\n", key, value));
        }
        yaml.push('\n');

        // Default settings
        yaml.push_str("default:\n");
        yaml.push_str("  image: rust:latest\n");
        yaml.push_str("  before_script:\n");
        yaml.push_str("    - apt-get update -qq && apt-get install -y -qq curl jq\n\n");

        // WIA Security scan job
        yaml.push_str(&self.generate_wia_scan_job());

        // SBOM job
        if self.config.scan_config.enable_sbom {
            yaml.push_str(&self.generate_sbom_job());
        }

        // Security gate job
        yaml.push_str(&self.generate_security_gate_job());

        // Report generation job
        yaml.push_str(&self.generate_report_job());

        Ok(yaml)
    }

    /// Generate WIA security scan job
    fn generate_wia_scan_job(&self) -> String {
        let mut job = String::new();

        job.push_str("wia-security-scan:\n");
        job.push_str("  stage: security\n");
        job.push_str("  image: rust:latest\n");
        job.push_str("  variables:\n");
        job.push_str("    GIT_STRATEGY: clone\n");
        job.push_str("  script:\n");
        job.push_str("    - echo \"Installing WIA Security Scanner...\"\n");
        job.push_str("    - curl -sSL https://raw.githubusercontent.com/WIA-Official/wia-standards/main/security/install.sh | bash\n");
        job.push_str("    - export PATH=\"$HOME/.wia-security/bin:$PATH\"\n");
        job.push_str("    - echo \"Running security scan...\"\n");
        job.push_str("    - |\n");
        job.push_str("      wia-security scan \\\n");
        job.push_str("        --fail-on-critical=$WIA_FAIL_ON_CRITICAL \\\n");
        job.push_str("        --fail-on-high=$WIA_FAIL_ON_HIGH \\\n");
        job.push_str("        --max-critical=$WIA_MAX_CRITICAL \\\n");
        job.push_str("        --max-high=$WIA_MAX_HIGH \\\n");
        job.push_str("        --output-format=gitlab-sast \\\n");
        job.push_str("        --output=gl-sast-report.json \\\n");
        job.push_str("        --json-output=wia-results.json \\\n");
        job.push_str("        .\n");
        job.push_str("  artifacts:\n");
        job.push_str("    reports:\n");
        job.push_str("      sast: gl-sast-report.json\n");
        job.push_str("    paths:\n");
        job.push_str("      - wia-results.json\n");
        job.push_str("      - gl-sast-report.json\n");
        job.push_str("    expire_in: 1 week\n");
        job.push_str("  rules:\n");
        job.push_str("    - if: $CI_COMMIT_BRANCH\n");
        job.push_str("      exists:\n");
        job.push_str("        - \"**/*.rs\"\n");
        job.push_str("        - \"**/*.py\"\n");
        job.push_str("        - \"**/*.js\"\n");
        job.push_str("        - \"**/*.ts\"\n");
        job.push_str("        - \"**/*.go\"\n");
        job.push_str("  allow_failure: false\n");
        job.push_str("  cache:\n");
        job.push_str("    key: wia-security-$CI_COMMIT_REF_SLUG\n");
        job.push_str("    paths:\n");
        job.push_str("      - .wia-security-cache/\n\n");

        job
    }

    /// Generate SBOM job
    fn generate_sbom_job(&self) -> String {
        let mut job = String::new();

        job.push_str("generate-sbom:\n");
        job.push_str("  stage: security\n");
        job.push_str("  image: anchore/syft:latest\n");
        job.push_str("  script:\n");
        job.push_str("    - syft . -o spdx-json > sbom.spdx.json\n");
        job.push_str("    - syft . -o cyclonedx-json > sbom.cyclonedx.json\n");
        job.push_str("  artifacts:\n");
        job.push_str("    paths:\n");
        job.push_str("      - sbom.spdx.json\n");
        job.push_str("      - sbom.cyclonedx.json\n");
        job.push_str("    expire_in: 90 days\n");
        job.push_str("  rules:\n");
        job.push_str("    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\n");

        job
    }

    /// Generate security gate job
    fn generate_security_gate_job(&self) -> String {
        let mut job = String::new();

        job.push_str("security-gate:\n");
        job.push_str("  stage: security\n");
        job.push_str("  needs:\n");
        job.push_str("    - job: wia-security-scan\n");
        job.push_str("      artifacts: true\n");
        job.push_str("  script:\n");
        job.push_str("    - echo \"Checking security gate...\"\n");
        job.push_str("    - |\n");
        job.push_str("      CRITICAL=$(jq '.summary.critical // 0' wia-results.json)\n");
        job.push_str("      HIGH=$(jq '.summary.high // 0' wia-results.json)\n");
        job.push_str("      echo \"Critical: $CRITICAL, High: $HIGH\"\n");
        job.push_str("      \n");
        job.push_str("      if [ \"$WIA_FAIL_ON_CRITICAL\" = \"true\" ] && [ \"$CRITICAL\" -gt \"$WIA_MAX_CRITICAL\" ]; then\n");
        job.push_str("        echo \"SECURITY GATE FAILED: Critical vulnerabilities ($CRITICAL) exceed threshold ($WIA_MAX_CRITICAL)\"\n");
        job.push_str("        exit 1\n");
        job.push_str("      fi\n");
        job.push_str("      \n");
        job.push_str("      if [ \"$WIA_FAIL_ON_HIGH\" = \"true\" ] && [ \"$HIGH\" -gt \"$WIA_MAX_HIGH\" ]; then\n");
        job.push_str("        echo \"SECURITY GATE FAILED: High vulnerabilities ($HIGH) exceed threshold ($WIA_MAX_HIGH)\"\n");
        job.push_str("        exit 1\n");
        job.push_str("      fi\n");
        job.push_str("      \n");
        job.push_str("      echo \"Security gate passed!\"\n");
        job.push_str("  rules:\n");
        job.push_str("    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n");
        job.push_str("    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\n");

        job
    }

    /// Generate report job
    fn generate_report_job(&self) -> String {
        let mut job = String::new();

        job.push_str("security-report:\n");
        job.push_str("  stage: security\n");
        job.push_str("  needs:\n");
        job.push_str("    - job: wia-security-scan\n");
        job.push_str("      artifacts: true\n");
        job.push_str("  script:\n");
        job.push_str("    - echo \"Generating security report...\"\n");
        job.push_str("    - |\n");
        job.push_str("      cat << 'EOF' > security-summary.md\n");
        job.push_str("      # Security Scan Summary\n");
        job.push_str("      \n");
        job.push_str("      **Pipeline:** $CI_PIPELINE_ID\n");
        job.push_str("      **Branch:** $CI_COMMIT_BRANCH\n");
        job.push_str("      **Commit:** $CI_COMMIT_SHORT_SHA\n");
        job.push_str("      \n");
        job.push_str("      ## Findings\n");
        job.push_str("      EOF\n");
        job.push_str("    - jq -r '\"- Critical: \\(.summary.critical // 0)\\n- High: \\(.summary.high // 0)\\n- Medium: \\(.summary.medium // 0)\\n- Low: \\(.summary.low // 0)\"' wia-results.json >> security-summary.md\n");
        job.push_str("  artifacts:\n");
        job.push_str("    paths:\n");
        job.push_str("      - security-summary.md\n");
        job.push_str("    expire_in: 30 days\n");
        job.push_str("  rules:\n");
        job.push_str("    - if: $CI_COMMIT_BRANCH\n\n");

        job
    }

    /// Generate Auto DevOps override
    pub fn generate_auto_devops_override(&self) -> CicdResult<String> {
        let yaml = r#"# WIA Security - Auto DevOps Override
# Include this file in your .gitlab-ci.yml to enhance Auto DevOps with WIA Security

include:
  - template: Auto-DevOps.gitlab-ci.yml

variables:
  AUTO_DEVOPS_PLATFORM_TARGET: ""
  SAST_DISABLED: "false"
  DEPENDENCY_SCANNING_DISABLED: "false"
  SECRET_DETECTION_DISABLED: "false"
  CONTAINER_SCANNING_DISABLED: "false"

# Override SAST with WIA Security
sast:
  stage: test
  image: rust:latest
  script:
    - curl -sSL https://raw.githubusercontent.com/WIA-Official/wia-standards/main/security/install.sh | bash
    - $HOME/.wia-security/bin/wia-security scan --output-format=gitlab-sast --output=gl-sast-report.json .
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
"#;

        Ok(yaml.to_string())
    }

    /// Generate compliance framework template
    pub fn generate_compliance_template(&self) -> CicdResult<String> {
        let yaml = r#"# WIA Security Compliance Pipeline Template
# Use this template for regulated environments

stages:
  - compliance-check
  - security-scan
  - audit

variables:
  COMPLIANCE_FRAMEWORK: "SOC2"  # Options: SOC2, HIPAA, PCI-DSS, ISO27001

compliance-check:
  stage: compliance-check
  script:
    - echo "Checking compliance with $COMPLIANCE_FRAMEWORK..."
    - |
      case $COMPLIANCE_FRAMEWORK in
        SOC2)
          echo "Applying SOC 2 Type II controls..."
          ;;
        HIPAA)
          echo "Applying HIPAA security controls..."
          ;;
        PCI-DSS)
          echo "Applying PCI-DSS requirements..."
          ;;
        ISO27001)
          echo "Applying ISO 27001 controls..."
          ;;
      esac
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security-scan:
  stage: security-scan
  script:
    - curl -sSL https://raw.githubusercontent.com/WIA-Official/wia-standards/main/security/install.sh | bash
    - $HOME/.wia-security/bin/wia-security scan --compliance=$COMPLIANCE_FRAMEWORK --output=compliance-report.json .
  artifacts:
    paths:
      - compliance-report.json
    expire_in: 1 year
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

audit-log:
  stage: audit
  needs:
    - compliance-check
    - security-scan
  script:
    - |
      cat << EOF > audit-log.json
      {
        "timestamp": "$(date -Iseconds)",
        "pipeline_id": "$CI_PIPELINE_ID",
        "commit": "$CI_COMMIT_SHA",
        "branch": "$CI_COMMIT_BRANCH",
        "framework": "$COMPLIANCE_FRAMEWORK",
        "status": "completed"
      }
      EOF
  artifacts:
    paths:
      - audit-log.json
    expire_in: 7 years  # Compliance retention
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
"#;

        Ok(yaml.to_string())
    }

    /// Generate GitLab SAST report format
    pub fn generate_sast_report(scan: &super::super::importers::WiaScanResult) -> serde_json::Value {
        let mut vulnerabilities = Vec::new();

        for target in &scan.targets {
            for finding in &target.findings {
                let severity = match finding.severity.as_str() {
                    "critical" => "Critical",
                    "high" => "High",
                    "medium" => "Medium",
                    "low" => "Low",
                    _ => "Info",
                };

                let mut identifiers = Vec::new();
                for cve in &finding.cve {
                    identifiers.push(serde_json::json!({
                        "type": "cve",
                        "name": cve,
                        "value": cve,
                        "url": format!("https://nvd.nist.gov/vuln/detail/{}", cve)
                    }));
                }

                vulnerabilities.push(serde_json::json!({
                    "id": finding.id,
                    "category": "sast",
                    "name": finding.title,
                    "message": finding.description,
                    "description": finding.description,
                    "severity": severity,
                    "confidence": "High",
                    "scanner": {
                        "id": "wia-security",
                        "name": "WIA Security Scanner"
                    },
                    "location": {
                        "file": target.host,
                        "start_line": finding.port.unwrap_or(0)
                    },
                    "identifiers": identifiers,
                    "solution": finding.solution
                }));
            }
        }

        serde_json::json!({
            "version": "15.0.0",
            "vulnerabilities": vulnerabilities,
            "scan": {
                "scanner": {
                    "id": "wia-security",
                    "name": "WIA Security Scanner",
                    "version": "1.0.0",
                    "vendor": {
                        "name": "WIA"
                    }
                },
                "type": "sast",
                "status": "success",
                "start_time": scan.scan_time,
                "end_time": chrono::Utc::now().to_rfc3339()
            }
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_pipeline() {
        let config = GitLabCiConfig::default();
        let generator = GitLabCiGenerator::new(config);

        let yaml = generator.generate_pipeline().unwrap();

        assert!(yaml.contains("stages:"));
        assert!(yaml.contains("wia-security-scan:"));
        assert!(yaml.contains("security-gate:"));
    }

    #[test]
    fn test_generate_compliance_template() {
        let config = GitLabCiConfig::default();
        let generator = GitLabCiGenerator::new(config);

        let yaml = generator.generate_compliance_template().unwrap();

        assert!(yaml.contains("COMPLIANCE_FRAMEWORK"));
        assert!(yaml.contains("SOC2"));
    }
}
