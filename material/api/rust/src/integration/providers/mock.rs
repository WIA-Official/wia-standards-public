//! Mock provider for testing

use async_trait::async_trait;
use chrono::Utc;
use std::collections::HashMap;
use std::sync::RwLock;

use super::traits::{DataProvider, ProviderConfig, ProviderQuery, ProviderStatus};
use crate::integration::error::{IntegrationError, IntegrationResult};
use crate::types::{
    ExternalReferences, Identity, MaterialData, MaterialType, Meta, Properties, Provenance,
    Timestamp,
};

/// Mock provider for testing and development
pub struct MockProvider {
    name: String,
    connected: bool,
    materials: RwLock<HashMap<String, MaterialData>>,
}

impl MockProvider {
    /// Create a new mock provider
    pub fn new() -> Self {
        Self {
            name: "mock".to_string(),
            connected: false,
            materials: RwLock::new(HashMap::new()),
        }
    }

    /// Add sample data for testing
    pub fn populate_sample_data(&self) {
        let mut materials = self.materials.write().unwrap();

        // Sample YBCO superconductor
        materials.insert(
            "mock-001".to_string(),
            create_sample_material(
                "mock-001",
                "YBCO",
                "YBa2Cu3O7-x",
                MaterialType::Superconductor,
            ),
        );

        // Sample Bi2Se3 topological insulator
        materials.insert(
            "mock-002".to_string(),
            create_sample_material(
                "mock-002",
                "Bismuth Selenide",
                "Bi2Se3",
                MaterialType::TopologicalInsulator,
            ),
        );

        // Sample TiO2 memristor
        materials.insert(
            "mock-003".to_string(),
            create_sample_material(
                "mock-003",
                "Titanium Dioxide Memristor",
                "TiO2",
                MaterialType::Memristor,
            ),
        );

        // Sample Fe2O3
        materials.insert(
            "mock-004".to_string(),
            create_sample_material("mock-004", "Hematite", "Fe2O3", MaterialType::Custom),
        );

        // Sample Fe3O4
        materials.insert(
            "mock-005".to_string(),
            create_sample_material("mock-005", "Magnetite", "Fe3O4", MaterialType::Custom),
        );
    }

    /// Add a material to the mock store
    pub fn add_material(&self, id: &str, material: MaterialData) {
        let mut materials = self.materials.write().unwrap();
        materials.insert(id.to_string(), material);
    }
}

impl Default for MockProvider {
    fn default() -> Self {
        Self::new()
    }
}

fn create_sample_material(
    id: &str,
    name: &str,
    formula: &str,
    material_type: MaterialType,
) -> MaterialData {
    let now = Utc::now();

    MaterialData {
        schema: Some("https://wia.live/material/v1/schema.json".to_string()),
        version: "1.0.0".to_string(),
        material_id: format!("wia-mat-{:08x}", rand_id() as u32),
        material_type,
        timestamp: Timestamp {
            created: now,
            modified: None,
        },
        identity: Identity {
            name: name.to_string(),
            formula: formula.to_string(),
            classification: Some(vec!["sample".to_string()]),
        },
        structure: None,
        properties: Properties::default(),
        measurement: None,
        provenance: Some(Provenance {
            source: Some("mock_provider".to_string()),
            lab: Some("Test Lab".to_string()),
            operator: None,
        }),
        external_references: Some(ExternalReferences {
            materials_project_id: None,
            icsd_id: None,
            cod_id: None,
            doi: None,
        }),
        meta: Some(Meta {
            confidence: Some(0.95),
            validated: Some(true),
            notes: Some(format!("Generated by mock provider for testing: {}", id)),
        }),
    }
}

fn rand_id() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64
}

#[async_trait]
impl DataProvider for MockProvider {
    fn name(&self) -> &str {
        &self.name
    }

    async fn connect(&mut self, _config: ProviderConfig) -> IntegrationResult<()> {
        self.connected = true;
        self.populate_sample_data();
        Ok(())
    }

    async fn disconnect(&mut self) -> IntegrationResult<()> {
        self.connected = false;
        Ok(())
    }

    fn is_connected(&self) -> bool {
        self.connected
    }

    async fn status(&self) -> IntegrationResult<ProviderStatus> {
        let count = self.materials.read().unwrap().len();
        Ok(ProviderStatus {
            name: self.name.clone(),
            connected: self.connected,
            version: "1.0.0".to_string(),
            available_count: Some(count),
            last_connected: if self.connected {
                Some(Utc::now().to_rfc3339())
            } else {
                None
            },
        })
    }

    async fn search(&self, query: &ProviderQuery) -> IntegrationResult<Vec<MaterialData>> {
        if !self.connected {
            return Err(IntegrationError::ProviderNotConnected(self.name.clone()));
        }

        let materials = self.materials.read().unwrap();
        let mut results: Vec<MaterialData> = materials.values().cloned().collect();

        // Apply filters
        if let Some(ref material_type) = query.material_type {
            results.retain(|m| &m.material_type == material_type);
        }

        if let Some(ref formula) = query.formula {
            results.retain(|m| m.identity.formula.to_lowercase() == formula.to_lowercase());
        }

        if let Some(ref name) = query.name_contains {
            let name_lower = name.to_lowercase();
            results.retain(|m| m.identity.name.to_lowercase().contains(&name_lower));
        }

        if let Some(ref elements) = query.elements {
            results.retain(|m| {
                let formula = &m.identity.formula;
                elements.iter().all(|e| formula.contains(e))
            });
        }

        // Apply pagination
        let offset = query.offset.unwrap_or(0);
        let limit = query.limit.unwrap_or(100);

        results = results.into_iter().skip(offset).take(limit).collect();

        Ok(results)
    }

    async fn get_by_id(&self, external_id: &str) -> IntegrationResult<MaterialData> {
        if !self.connected {
            return Err(IntegrationError::ProviderNotConnected(self.name.clone()));
        }

        let materials = self.materials.read().unwrap();
        materials
            .get(external_id)
            .cloned()
            .ok_or_else(|| IntegrationError::ExternalIdNotFound(external_id.to_string()))
    }

    async fn get_by_wia_id(&self, wia_id: &str) -> IntegrationResult<Option<MaterialData>> {
        if !self.connected {
            return Err(IntegrationError::ProviderNotConnected(self.name.clone()));
        }

        let materials = self.materials.read().unwrap();
        Ok(materials.values().find(|m| m.material_id == wia_id).cloned())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_mock_provider_connect() {
        let mut provider = MockProvider::new();
        assert!(!provider.is_connected());

        provider.connect(ProviderConfig::default()).await.unwrap();
        assert!(provider.is_connected());

        let status = provider.status().await.unwrap();
        assert!(status.available_count.unwrap() > 0);
    }

    #[tokio::test]
    async fn test_mock_provider_search() {
        let mut provider = MockProvider::new();
        provider.connect(ProviderConfig::default()).await.unwrap();

        let query = ProviderQuery::new().with_type(MaterialType::Superconductor);
        let results = provider.search(&query).await.unwrap();

        assert!(!results.is_empty());
        assert!(results
            .iter()
            .all(|m| m.material_type == MaterialType::Superconductor));
    }

    #[tokio::test]
    async fn test_mock_provider_elements_search() {
        let mut provider = MockProvider::new();
        provider.connect(ProviderConfig::default()).await.unwrap();

        let query = ProviderQuery::new().with_elements(vec!["Fe".to_string(), "O".to_string()]);
        let results = provider.search(&query).await.unwrap();

        assert!(!results.is_empty());
        assert!(results.iter().all(|m| m.identity.formula.contains("Fe")));
    }

    #[tokio::test]
    async fn test_mock_provider_get_by_id() {
        let mut provider = MockProvider::new();
        provider.connect(ProviderConfig::default()).await.unwrap();

        let material = provider.get_by_id("mock-001").await.unwrap();
        assert_eq!(material.identity.name, "YBCO");
    }
}
